package main

import (
	"fmt"
	"io/fs"
	"os"
	"reflect"
	"strings"

	"cuelang.org/go/cue/ast"
	"cuelang.org/go/cue/parser"
	"cuelang.org/go/cue/token"
)

const Version = "0.0.3-alpha"

var PackageName string

func main() {
	// dolus/expectation.cue
	if len(os.Args) == 4 {
		PackageName = os.Args[3]
	}
	goCode, err := generateGoCodeFromCueDefinitionFile(os.Args[1])
	if err != nil {
		fmt.Println("Error: ", err)
		os.Exit(1)
	}

	if err := os.WriteFile(os.Args[2], []byte(goCode), fs.ModePerm); err != nil {
		fmt.Println("Error: ", err)
		os.Exit(1)
	}

	fmt.Printf("Data from %s successfully written to file %s\n", os.Args[1], os.Args[2])
}

func generateGoCodeFromCueDefinitionFile(filename string) (string, error) {
	goCode := strings.Builder{}
	goCode.WriteString(
		fmt.Sprintf("// DO NOT EDIT! Code was generated by cue2gostruct v%s.\n\n", Version),
	)
	file, err := parser.ParseFile(filename, nil, parser.ParseComments)
	if err != nil {
		return "", err
	}
	traverseAST(file, 0, nil, false, &goCode)
	return goCode.String(), nil
}

type FieldLabel struct {
	label    string
	optional bool
}

func traverseAST(
	node ast.Node,
	depth int,
	fieldLabel *FieldLabel,
	inStruct bool,
	goCode *strings.Builder,
) {
	indent := ""
	for i := 0; i < depth; i++ {
		indent += "  "
	}

	// fmt.Println(reflect.TypeOf(node))
	switch n := node.(type) {
	case *ast.Field:
		label := fmt.Sprintf("%s", n.Label)
		traverseAST(n.Value, depth, &FieldLabel{
			label:    label,
			optional: n.Constraint == token.OPTION,
		}, inStruct, goCode)

	case *ast.StructLit:
		label := fieldLabel.label
		if !strings.HasPrefix(label, "#") {
			panic(fmt.Sprintf("Illegal struct definition found at: %s", n.Pos()))
		}
		label = label[1:]
		goCode.WriteString(fmt.Sprintf("type %s struct { \n", label))
		// go through struct fields
		for _, elem := range n.Elts {
			traverseAST(elem, depth+1, nil, true, goCode)
		}
		goCode.WriteString("}\n\n")

	case *ast.Ident:
		typ := n.Name
		if typ == "_" {
			typ = "any"
		}
		typ = strings.TrimPrefix(typ, "#")
		if fieldLabel.optional && typ != "any" {
			typ = fmt.Sprintf("*%s", typ)
		}
		l := (strings.ToLower(fieldLabel.label[:1]) + fieldLabel.label[1:])
		typ = fmt.Sprintf("%s `json:\"%s\"`", typ, l)
		l = (strings.ToUpper(fieldLabel.label[:1]) + fieldLabel.label[1:])

		goCode.WriteString(fmt.Sprintf("%s%s %s\n", indent, l, typ))

	case *ast.File:
		for i := 0; i < len(n.Decls); i++ {
			traverseAST(n.Decls[i], depth, fieldLabel, inStruct, goCode)
		}

	case *ast.BinaryExpr:
		traverseAST(n.X, depth, fieldLabel, inStruct, goCode)

	case *ast.BasicLit:
		if inStruct {
			l := (strings.ToLower(fieldLabel.label[:1]) + fieldLabel.label[1:])
			typ := fmt.Sprintf("%s `json:\"%s\"`", strings.ToLower(n.Kind.String()), l)
			l = (strings.ToUpper(fieldLabel.label[:1]) + fieldLabel.label[1:])
			goCode.WriteString(fmt.Sprintf("%s%s %s\n", indent, l, typ))
		} else {
			goCode.WriteString(fmt.Sprintf("%stype %s %s\n\n", indent, fieldLabel.label, strings.ToLower(n.Kind.String())))
		}

	case *ast.Package:
		if PackageName == "" {
			goCode.WriteString(fmt.Sprintf("package %s\n\n", n.Name))
		} else {
			goCode.WriteString(fmt.Sprintf("package %s\n\n", PackageName))
		}

		// fmt.Printf("package %s\n\n", n.Name)
	case *ast.Comment:
		// TODO comments not displaying
		fmt.Println("Comment!!!", n.Text)
		goCode.WriteString(fmt.Sprintf("%+s", n.Text))
	case *ast.UnaryExpr:
		// fmt.Printf("%sUnary: %+v\n", indent, n.X)
		traverseAST(n.X, depth, fieldLabel, inStruct, goCode)

	case *ast.ListLit:
		// fmt.Printf("%sList: %+v\n", indent, reflect.TypeOf(n.Elts[0]))
		traverseAST(n.Elts[0], depth, fieldLabel, inStruct, goCode)
	case *ast.Ellipsis:
		typ := fmt.Sprintf("%s", n.Type)
		if typ == "_" {
			typ = "[]any"
		} else {
			typ = strings.TrimPrefix(typ, "#")
			typ = fmt.Sprintf("[]%s", typ)
		}

		if fieldLabel.optional && typ != "any" {
			typ = fmt.Sprintf("*%s", typ)
		}
		l := (strings.ToLower(fieldLabel.label[:1]) + fieldLabel.label[1:])
		typ = fmt.Sprintf("%s `json:\"%s\"`", typ, l)
		l = (strings.ToUpper(fieldLabel.label[:1]) + fieldLabel.label[1:])

		goCode.WriteString(fmt.Sprintf("%s%s  %s\n", indent, l, typ))

	default:
		panic(fmt.Sprintf("Unhandled type: %s", reflect.TypeOf(n)))
	}
}
